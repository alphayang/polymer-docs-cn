---
title: 访问应用
---

<!-- toc -->

可以使用任意的服务器来提供 App Toolbox 应用的访问. Polymer CLI 构建过程支持快速应用加载可以利用最新的web技术,会生成2个版本:

-   非绑定的构建用来提供支持HTTP/2和HTTP/2服务器器推送的服务器/浏览器组合,浏览器可以使用优化缓存来达到快速首次加载.

-   绑定的构建用来提供在服务器/浏览器组合不支持服务器推送时最小化应用加载所需网络请求数量.

服务器逻辑可以对每个浏览器提供相应的版本.

## PRPL 模式

为了优化传输,  Toolbox 使用了 _PRPL 模式, 它包含
:

*  在初始化路由于推送关键资源.
*  渲染初始化路由.
*  预缓存剩余路由.
*  按需加载和创建剩余路由.

为了达到这个目的,服务器需要识别出每个应用路由所需的资源. 它使用HTTP2推送来发送请求路由所需的资源,而不是将所有资源打包为一个来进行下载.

服务器和 service worker 一起合作来预缓存非活动路由所需的资源.

当用户切换路由时, 应用按需加载任意没有缓存的所需资源并创建所请求视图.

## 应用结构

当前, Polymer CLI 和  服务器支持具有以下结构的单页应用:

-   应用的主 _入口_ 由每一个有效的路由提供. 这些文件应当很小, 由于它可以不同的URL访问并多次缓存. 所有在入口中的资源URL必须是绝对路径, 由于它也可能在非顶层URL中访问.

-    _shell_ 或 app-shell, 包含了顶层应用逻辑,路由等等.

-   应用中延迟加载的 _片段_ . 片段表示特定的视图代码或其它可被延迟加载的代码(例如主应用中不需要首次渲染的部分,菜单只需在用户与应用交互时才需显示).
    Shell 负责动态按需导入片段.

下图展示了一个简单应用的组件:

![diagram of an app that has two views, which have both individual and shared dependencies](/images/1.0/toolbox/app-build-components.png)

图中, 实绩表示 _静态依赖_, 外部资源使用 `<link>` 和 `<script>` 标记来表示. 虚线表示 _动态_ 或 _按需加载的依赖_: 文件在shell需要时被加载.

构建过程生成一个所有依赖的图, 服务器会使用这些信息来更有效的提供文件访问. 同时也为不支持HTTP2推送的浏览器生成了资源.

### 应用入口

入口必须在shell中引入并实例化, 其它所需的polyfills也同样要在此时有条件的加载.

入口的主要作用是:

-   最小化静态依赖-除了应用shell自身.
-   有条件的加载所需polyfills.
-   所有依赖使用绝对路径.

当使用Polymer CLI来生成一个App Toolbox项目时,新项目包含一个`index.html`入口的. 大多数项目中不需要再更新这个文件.

### 应用 shell

 Shell 负责路由以及包含应用的主导航UI.

应用必须调用 `importHref` 以更在需要时来延迟加载片段. 例如当用户到新的路由时再导入路由与关联的片段.
这个可能会生成一个新的服务器请求或者简单从缓存中加载资源.

    importHref('list-view.html');

shell (以及它的静态依赖) 必须包括它首次渲染所需的一切资源.

## 构建输出

Polymer CLI 构建流程会生成两个版本:

-   非绑定的构建用来提供支持HTTP/2和HTTP/2服务器器推送的服务器/浏览器组合,浏览器可以使用优化缓存来达到快速首次加载.

-   绑定的构建用来提供在服务器/浏览器组合不支持服务器推送时最小化应用加载所需网络请求数量.

`polymer build` 命令输出两个版本到各自的目录中:

	build/
	  unbundled/
	    index.html
	    ...
	  bundled/
	    index.html
	    ...

服务器需要对各个浏览器返回相应的版本.

### 绑定构建

对于不运行HTTP2推送的浏览器, 构建流程生成一组绑定内容:
shell对应的绑定, 每个片段对应的绑定. 下图所示一个简单的绑定应用:

![diagram of the same app as before, where there are 3 bundled dependencies](/images/1.0/toolbox/app-build-bundles.png)

任意在两个以上片段中共享的依赖都被绑定到shell和它的静态依赖中.

各个片段和它的 _非共享_ 静态依赖添加到一个单独的绑定中. 服务器应当基于浏览器返回片段相应的版本(绑定或非绑定).
这意味着shell代码可以延迟加载 `detail-view.html` _不论是否知道它是绑定还是非绑定的_. 这取决于服务器与浏览器以最有效的方式来加载依赖.


## 背景知识: HTTP/2 和 HTTP/2 服务器推送

HTTP/2 允许在一个链接中 _多路复用_ 下载, 所以多个小文件可以更高效的被下载.

HTTP/2 服务器推送允许服务器抢先发送资源给浏览器.

例如使用HTTP/2服务器推送来提升下载速度,浏览器请求一个带有链接样式表的HTML文件.

在 HTTP/1 中:
*   浏览器请求HTML文件.
*   浏览器返回HTML文件,浏览器开始解析文件.
*   浏览器遇到 `<link rel="stylesheet">` 标记然后开始一个新的样式表请求.
*   浏览器接收样式表.

在 HTTP/2 推送中:
*   浏览器请求HTML文件.
*   服务器返回HTML文件并同时推送样式表.
*   浏览器开发解析HTML文件.遇到 `<link rel="stylesheet">` 时样式表已经位于缓存中.

在这个简单案例中, HTTP/2 服务器推送server push 减少了一个HTTP请求和返回.

在 HTTP/1 中, 开发者需要将资源打包在一起来减少为了渲染一个页面而需要的HTTP请求数. 然后打包也会降低浏览器缓存的效率. 如果每个页面中的资源都合并成一个资源, 那么各个页面都有自己的绑定,浏览器就不会识别共享的资源了.

HTTP/2 和 HTTP/2 服务器推送组合可以提供绑定的 _好处_  (降低延时) 而又不对资源进行绑定. 保持资源的离散意味着更高效的缓存和页面间共享.
